# 内核级线程
## 开始核心级线程
![](images/2021-07-01-00-23-47.png)
![](images/2021-07-01-00-23-59.png)
系统中有多个核心，使用多核核心级线程同时给多个分配任务，同时触发，同时执行，成为并行。
跟之前学习的同时触发，交替执行的逻辑做一个区别，之前的叫做并发。

内核态和用户态的线程切换不同，用户态是切换TCB和栈，而内核态中是要切换TCB和**一套栈**。一套栈包括了线程的用户栈和内核栈，内核栈通过压入的指针将两个栈关联起来。

* 从用户态线程运行到内核态线程，完成栈的关联
![](images/2021-07-01-00-39-56.png)

* 进入线程的内核中之后，如果遇到阻塞，需要切换到其他的内核态的线程中去。在切换完成之后，从切换的内核态线程的内核iret返回该线程的用户态中去执行。
![](images/2021-07-01-00-49-46.png)

## 内核线程switch_to的五段论

* 通过中断进入内核态
  ![](images/2021-07-01-00-53-54.png)

* 进行中断处理函数，如果遇到阻塞，就要切换到其他线程。
![](images/%20%20![](images/2021-07-01-00-55-25.png).png)

* 通过调度函数schedule下跳转到switch_to来切换内核线程。
![](images/2021-07-01-00-57-50.png)

* 在内核中进行TCB的切换
![](images/2021-07-01-00-58-25.png)

* 内核切换完成之后通过iret回到切换的线程的用户态下执行程序
![](images/2021-07-01-00-59-06.png)

## 线程创建
``` C
void ThreadCreate()
{
    TCB tcb = get_free_page();
    *krlstack = ...;
    *userstack传入;
    /*
     * TODO: 填写两个stack;
     */
    tcb.esp=krlstack;
    tcb.state=就绪;
    tcb入队；
}
```